import lighthouse from "@lighthouse-web3/sdk";
import { BrowserProvider } from "ethers";
import { useState } from "react";

const provider =
  typeof window !== "undefined"
    ? new BrowserProvider((window as any).ethereum)
    : undefined;

const useLighthouse = () => {
  const [fileURL, setFileURL] = useState<any>();
  const [cid, SetCid] = useState("");
  const [account, setAccount] = useState("");

  const { ethereum } = window as any;

  if (!ethereum) {
    alert("please install metamask");
  }

  const encryptionSignature = async () => {
    const accounts = await ethereum.request({
      method: "eth_requestAccounts",
    });

    const signer = await provider?.getSigner();

    const address = await signer!.getAddress();
    const messageRequested = (await lighthouse.getAuthMessage(address)).data
      .message;
    const signedMessage = await signer!.signMessage(messageRequested);
    setAccount(accounts[0]);
    return {
      signedMessage: signedMessage,
      publicKey: address,
    };
  };

  const progressCallback = (progressData: {
    total: number;
    uploaded: number;
  }) => {
    let percentageDone =
      100 -
      parseFloat((progressData?.total / progressData?.uploaded)?.toFixed(2));
    console.log(percentageDone);
  };

  /* Deploy file along with encryption */
  const uploadFileEncrypted = async (file: any) => {
    /*
     uploadEncrypted(e, accessToken, publicKey, signedMessage, uploadProgressCallback)
     - e: js event
     - accessToken: your API key
     - publicKey: wallets public key
     - signedMessage: message signed by the owner of publicKey
     - dealParameters: default null
     - uploadProgressCallback: function to get progress (optional)
  */
    const sig = await encryptionSignature();
    const response = await lighthouse.uploadEncrypted(
      file,
      process.env.NEXT_PUBLIC_LIGHTHOUSE_API_KEY || "",
      sig!.publicKey,
      sig!.signedMessage,
      undefined,
      progressCallback
    );
    console.log(response.data);
    const { Hash } = response.data[0];
    SetCid(Hash);
    /*
    output:
      data: [{
        Name: "c04b017b6b9d1c189e15e6559aeb3ca8.png",
        Size: "318557",
        Hash: "QmcuuAtmYqbPYmPx3vhJvPDi61zMxYvJbfENMjBQjq7aM3"
      }]
    Note: Hash in response is CID.
  */
  };

  const applyAccessConditions = async (cid: string) => {
    // CID on which you are applying encryption
    // CID is generated by uploading a file with encryption
    // Only the owner of the file can apply access conditions

    // Conditions to add
    const conditions = [
      {
        id: 1,
        chain: "Calibration",
        method: "isSubscribedToDAO",
        standardContractType: "Custom",
        contractAddress: "0x599600F39C880F699440FFD7baB0C0dfE2c57f6A",
        returnValueTest: {
          comparator: "==",
          value: "1",
        },
        inputArrayType: ["address"],
        parameters: [":userAddress"],
        outputType: "uint256",
      },
    ];

    // Aggregator is what kind of operation to apply to access conditions
    // Suppose there are two conditions then you can apply ([1] and [2]), ([1] or [2]), !([1] and [2]).
    const aggregator = "([1])";
    const { publicKey, signedMessage } = await encryptionSignature();

    /*
      accessCondition(publicKey, cid, signedMessage, conditions, aggregator)
        Parameters:
          publicKey: owners public key
          CID: CID of the file to decrypt
          signedMessage: message signed by the owner of publicKey
          conditions: should be in a format like above
          aggregator: aggregator to apply conditions
    */
    const response = await lighthouse.applyAccessCondition(
      publicKey,
      cid,
      signedMessage,
      conditions,
      aggregator
    );

    console.log(response);
    /*
      {
        data: {
          cid: "QmZkEMF5y5Pq3n291fG45oyrmX8bwRh319MYvj7V4W4tNh",
          status: "Success"
        }
      }
    */
  };

  /* Decrypt file */
  const decrypt = async (cid: string) => {
    // Fetch file encryption key
    const { publicKey, signedMessage } = await encryptionSignature();
    /*
        fetchEncryptionKey(cid, publicKey, signedMessage)
          Parameters:
            CID: CID of the file to decrypt
            publicKey: public key of the user who has access to file or owner
            signedMessage: message signed by the owner of publicKey
      */

    const keyObject = await lighthouse.fetchEncryptionKey(
      cid,
      publicKey,
      signedMessage
    );

    // Decrypt file
    /*
        decryptFile(cid, key, mimeType)
          Parameters:
            CID: CID of the file to decrypt
            key: the key to decrypt the file
            mimeType: default null, mime type of file
      */

    const fileType = "application/json";
    const decrypted = await lighthouse.decryptFile(
      cid,
      keyObject.data.key!,
      fileType
    );

    console.log(decrypted);
    /*
        Response: blob
      */

    // View File
    const url = URL.createObjectURL(decrypted);
    console.log(url);
    setFileURL(url);
  };

  return {
    decrypt,
    applyAccessConditions,
    uploadFileEncrypted,
    encryptionSignature,
    account,
    cid,
    fileURL,
  };
};

export default useLighthouse;
